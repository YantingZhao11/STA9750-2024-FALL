---
title: "mp02.qmd"
editor: visual
---
```{r echo=FALSE, message=FALSE}
install.packages("stringr")
install.packages("dplyr")
library(stringr)
library(dplyr)


get_imdb_file <- function(fname, path){
    fname_ext <- file.path(path, paste0(fname, "_small.csv"))
    as.data.frame(readr::read_csv(fname_ext, lazy=FALSE))
}

# Example usage: specify the path where your CSV files are stored
path <- "C:\\Users\\w3038\\Downloads\\STA 9750"

NAME_BASICS      <- get_imdb_file("name_basics", path)
TITLE_BASICS     <- get_imdb_file("title_basics", path)
TITLE_CREW       <- get_imdb_file("title_crew", path)
TITLE_EPISODES   <- get_imdb_file("title_episodes", path)
TITLE_PRINCIPALS <- get_imdb_file("title_principals", path)
TITLE_RATINGS <- get_imdb_file("title_ratings", path)

NAME_BASICS <- NAME_BASICS |> 
    filter(str_count(knownForTitles, ",") > 1)

TITLE_RATINGS <- TITLE_RATINGS |>
    filter(numVotes >= 100)

TITLE_BASICS <- TITLE_BASICS |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))

TITLE_CREW <- TITLE_CREW |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))

TITLE_EPISODES_1 <- TITLE_EPISODES |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))
TITLE_EPISODES_2 <- TITLE_EPISODES |>
    semi_join(TITLE_RATINGS, 
              join_by(parentTconst == tconst))

TITLE_EPISODES <- bind_rows(TITLE_EPISODES_1,
                            TITLE_EPISODES_2) |>
    distinct()

TITLE_PRINCIPALS <- TITLE_PRINCIPALS |>
    semi_join(TITLE_RATINGS, join_by(tconst == tconst))


rm(TITLE_EPISODES_1)
rm(TITLE_EPISODES_2)

NAME_BASICS <- NAME_BASICS |>
    mutate(birthYear = as.numeric(str_replace_all(birthYear, "[^0-9]", "")),
           deathYear = as.numeric(str_replace_all(deathYear, "[^0-9]", "")))
#Task1
TITLE_BASICS <- TITLE_BASICS |>
    mutate(isAdult = as.logical(as.numeric(isAdult)),
      startYear = as.numeric(startYear),
           endYear = as.numeric(endYear),
           runtimeMinutes = as.numeric(str_replace_all(runtimeMinutes, "[^0-9]", "")))

TITLE_EPISODES <- TITLE_EPISODES |>
    mutate(seasonNumber = as.numeric(seasonNumber),
           episodeNumber = as.numeric(episodeNumber))

#Task2.1 How many movies are in our data set? How many TV series? How many TV episodes?

num_movies <- TITLE_BASICS |>
    filter(titleType == "movie") |>
    count()

num_tv_series <- TITLE_BASICS |>
    filter(titleType == "tvSeries") |>
    count()

num_tv_episodes <- TITLE_BASICS |>
    filter(titleType == "tvEpisode") |>
    count()

cat("Movie total:", num_movies$n, "\n")
cat("TV Series total:", num_tv_series$n, "\n")
cat("TV Episodes total:", num_tv_episodes$n, "\n")

#Task.2 Who is the oldest living person in our data set?
oldest_living_person <- NAME_BASICS |>
    filter(is.na(deathYear)) |>
    arrange(birthYear) |>
    slice(1)

# Print the details of the oldest living person
cat("The oldest living person in the dataset is:", 
    oldest_living_person$primaryName, 
    "born in", oldest_living_person$birthYear, "\n")

#Task2.3There is one TV Episode in this data set with a perfect 10/10 rating and 200,000 IMDb ratings. What is it? What series does it belong to?

# Find the TV Episode with a perfect 10 rating and 200,000 ratings
perfect_episode <- TITLE_RATINGS |>
  filter(averageRating == 10, numVotes == 200000)

# Check if we found any perfect episode
if(nrow(perfect_episode) > 0) {
    perfect_episode_details <- perfect_episode |>
        inner_join(TITLE_EPISODES, by = "tconst") |>
        select(tconst, parentTconst)

    # Join with Title_Basics to get the series information
    series_info <- TITLE_BASICS |>
        filter(tconst == perfect_episode_details$parentTconst) |>
        select(seriesTitle = primaryTitle)

    # Print the result
    cat("The TV episode with a perfect 10/10 rating and 200,000 IMDb ratings is:", 
        perfect_episode$tconst, 
        "from the series:", 
        series_info$seriesTitle, "\n")
} else {
    cat("No TV episode found with a perfect 10/10 rating and 200,000 IMDb ratings.\n")
}

#Task2.4What four projects is the actor Mark Hammill most known for?

# Find Mark Hamill's nconst
mark_hamill <- NAME_BASICS |>
  filter(primaryName == "Mark Hamill")

# Check if Mark Hamill was found
if(nrow(mark_hamill) > 0) {
    mark_hamill_nconst <- mark_hamill$nconst

    # Get the projects Mark Hamill is known for
    known_projects <- TITLE_PRINCIPALS |>
        filter(nconst == mark_hamill_nconst) |>
        inner_join(TITLE_BASICS, by = "tconst") |>
        select(primaryTitle, titleType) |>
        arrange(desc(titleType)) |>  # Sort by titleType
        slice(1:4)  # Get the top 4 projects

    # Print the projects
    cat("Mark Hamill is most known for the following projects:\n")
    print(known_projects)
} else {
    cat("Mark Hamill not found in the dataset.\n")
  
}

Task#2.5 What TV series, with more than 12 episodes, has the highest average rating?

# Step 1: Count the number of episodes for each series
episode_counts <- TITLE_EPISODES |>
    group_by(parentTconst) |>
    summarise(episode_count = n(), .groups = 'drop')

# Step 2: Join episode counts with Title Ratings
# We need to join with TITLE_BASICS to get the title name and ensure we're working with TV series
average_ratings <- episode_counts |>
    inner_join(TITLE_RATINGS, by = c("parentTconst" = "tconst")) |>
    inner_join(TITLE_BASICS, by = c("parentTconst" = "tconst")) |>
    filter(titleType == "tvSeries") |>
    select(seriesTitle = primaryTitle, episode_count, averageRating)

# Step 3: Filter for series with more than 12 episodes
filtered_series <- average_ratings |>
    filter(episode_count > 12)

# Step 4: Find the series with the highest average rating
top_series <- filtered_series |>
    arrange(desc(averageRating)) |>
    slice(1)

# Print the result
if (nrow(top_series) > 0) {
    cat("The TV series with more than 12 episodes and the highest average rating is:\n")
    print(top_series)
} else {
    cat("No TV series found with more than 12 episodes.\n")
  
}

#Task2.6 Is it true that episodes from later seasons of Happy Days have lower average ratings than the early seasons?

# Step 1: Get tconst for Happy Days
happy_days_tconst <- TITLE_BASICS |>
    filter(primaryTitle == "Happy Days") |>
    select(tconst)

# Step 2: Filter episodes for Happy Days and get their ratings
happy_days_episodes <- TITLE_EPISODES |>
    filter(parentTconst %in% happy_days_tconst$tconst) |>
    inner_join(TITLE_RATINGS, by = "tconst") |>
    mutate(seasonNumber = as.integer(seasonNumber))

# Step 3: Classify seasons into early and later
# Let's assume seasons 1-5 are early, and seasons 6-11 are later for this example
happy_days_episodes <- happy_days_episodes |>
    mutate(season_group = ifelse(seasonNumber <= 5, "Early", "Later"))

# Step 4: Calculate average ratings for early and later seasons
average_ratings <- happy_days_episodes |>
    group_by(season_group) |>
    summarise(average_rating = mean(averageRating, na.rm = TRUE), .groups = 'drop')

# Step 5: Print the results
print(average_ratings)

# Step 6: Check if later seasons have lower average ratings
if (nrow(average_ratings) == 2) {
    if (average_ratings$average_rating[average_ratings$season_group == "Later"] < 
        average_ratings$average_rating[average_ratings$season_group == "Early"]) {
        cat("True: Later seasons of Happy Days have lower average ratings than early seasons.\n")
    } else {
        cat("False: Later seasons of Happy Days do not have lower average ratings than early seasons.\n")
    }
} else {
    cat("Error: Unable to determine average ratings for early and later seasons.\n")
}

#Task3.1 Sucess Metric: Choose the top 5-10 movies on your metric and confirm that they were indeed box office successes.

# Step 1: Add a Success Score to TITLE_RATINGS
TITLE_RATINGS <- TITLE_RATINGS |>
    mutate(SuccessScore = averageRating * log(numVotes + 1))

# Step 2: Join TITLE_BASICS to get primaryTitle and get the top 5-10 movies based on the Success Score
top_movies <- TITLE_RATINGS |>
    inner_join(TITLE_BASICS, by = "tconst") |>
    arrange(desc(SuccessScore)) |>
    select(tconst, primaryTitle, averageRating, numVotes, SuccessScore) |>
    slice(1:10) # Change to slice(1:5) for the top 5

# Step 3: Print the top movies with their primary names
print(top_movies)

# Step 4: Validate box office success (Assuming you have a separate box office data frame)
# For demonstration, let's say you have a data frame called box_office_data
# which contains columns tconst and box_office_revenue

# Example box office data (you would replace this with your actual data)
# box_office_data <- data.frame(
#     tconst = c("tt0000001", "tt0000002", "tt0000003"), # Add actual movie tconsts
#     box_office_revenue = c(1000000, 2000000, 3000000) # Add corresponding revenues
# )

# Join with the top movies to check box office success
# validated_movies <- top_movies |>
#     inner_join(box_office_data, by = "tconst")

# Print the validated movies
# print(validated_movies)

#Task3.2 Choose 3-5 movies with large numbers of IMDb votes that score poorly on your success metric and confirm that they are indeed of low quality.
# Step 1: Add a Success Score to TITLE_RATINGS (if not done already)
TITLE_RATINGS <- TITLE_RATINGS |>
    mutate(SuccessScore = averageRating * log(numVotes + 1))

# Step 2: Choose movies with a large number of IMDb votes and low success scores
# Define a threshold for low success score (you can adjust this value as needed)
low_success_threshold <- mean(TITLE_RATINGS$SuccessScore) * 0.5

low_quality_movies <- TITLE_RATINGS |>
    filter(numVotes > 10000, SuccessScore < low_success_threshold) |>
    arrange(SuccessScore)

# Step 3: Join with TITLE_BASICS to include primary titles and select the top 5
low_quality_movies_with_titles <- low_quality_movies |>
    inner_join(TITLE_BASICS, by = "tconst") |>
    select(primaryTitle, averageRating, numVotes, SuccessScore) |>
    slice(1:5) # Select top 5 movies

# Print the validated low-quality movies with their titles
print(low_quality_movies_with_titles)

#Task3.3 Choose a prestige actor or director and confirm that they have many projects with high scores on your success metric.

# Step 1: Add a Success Score to TITLE_RATINGS (if not done already)
TITLE_RATINGS <- TITLE_RATINGS |>
    mutate(SuccessScore = averageRating * log(numVotes + 1))

# Step 2: Filter for Christopher Nolan's projects
# First, filter the TITLE_PRINCIPALS table to find projects involving Christopher Nolan
nolan_projects <- TITLE_PRINCIPALS |>
    filter(nconst == "nm0634240")  # Christopher Nolan's nconst

# Step 3: Join with TITLE_RATINGS and TITLE_BASICS to get the success scores and titles of his projects
nolan_success_projects <- nolan_projects |>
    inner_join(TITLE_RATINGS, by = "tconst") |>
    inner_join(TITLE_BASICS, by = "tconst") |>  # Join with TITLE_BASICS to get primaryTitle
    select(tconst, primaryTitle, averageRating, numVotes, SuccessScore) |>
    arrange(desc(SuccessScore))  # Sort by success score

# Step 4: Print the projects
print(nolan_success_projects)

# Step 5: Get a summary of the high-scoring projects
high_scoring_nolan_projects <- nolan_success_projects |>
    filter(SuccessScore > mean(nolan_success_projects$SuccessScore))  # Adjust threshold as needed

# Print the high-scoring projects
print(high_scoring_nolan_projects)


```