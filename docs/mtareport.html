<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Untitled – STA 9750 2024 Submission Material 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">STA 9750 2024 Submission Material 1</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Untitled</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="motivations-and-importance-of-analysis" class="level2">
<h2 class="anchored" data-anchor-id="motivations-and-importance-of-analysis">Motivations and Importance of Analysis</h2>
<p>We wanted to analyze borough-specific data to identify key subway challenges by combining ridership, delays, and safety metrics. Higher ridership often leads to increased delays, particularly in congested areas like Manhattan. Exploring the connection between delays and safety incidents revealed that recurring issues, such as track problems, impact both reliability and safety. Seasonal factors, like winter weather, further highlighted how external conditions affect system performance.</p>
</section>
<section id="quantitative-findings-and-their-qualitative-insights" class="level2">
<h2 class="anchored" data-anchor-id="quantitative-findings-and-their-qualitative-insights">Quantitative Findings and Their Qualitative Insights</h2>
<p>High ridership correlates with longer delays and increased safety risks, particularly during peak hours. Track-related issues emerged as a common cause of disruptions, emphasizing the need for preventive maintenance. Seasonal trends showed winter reducing system reliability, while other months performed better. Post-COVID patterns revealed shifting passenger habits and service gaps, particularly on busy lines.</p>
</section>
<section id="importance-of-this-analysis" class="level2">
<h2 class="anchored" data-anchor-id="importance-of-this-analysis">Importance of This Analysis</h2>
<p>By connecting ridership, delays, and safety, we uncovered critical issues like infrastructure strain, and seasonal impacts. These insights support targeted improvements, better maintenance, resource allocation, and weather-specific strategies to enhance reliability, safety, and rider experience. This analysis demonstrates how combined metrics drive meaningful, system-wide improvements.</p>
</section>
<section id="nyc-subway-incident-performance-and-ridership-analysis-incidents-safety-concerns" class="level2">
<h2 class="anchored" data-anchor-id="nyc-subway-incident-performance-and-ridership-analysis-incidents-safety-concerns">NYC Subway Incident, Performance, and Ridership Analysis Incidents &amp; Safety Concerns</h2>
<p>To address the motivating question regarding incidents and safety concerns, data was analyzed to identify the most common incident categories reported during and post-COVID. By categorizing incidents (e.g., mechanical issues, safety hazards, assaults, or overcrowding) across NYC subway lines, trends were identified from 2020 to 2024. Preliminary results revealed a sharp increase in safety-related incidents (e.g., assaults and disturbances) during the COVID period (2020-2021) as ridership fell and enforcement protocols shifted. Post-COVID (2022-2024), the data highlights an uptick in overcrowding-related incidents as ridership recovers, though safety incidents remain elevated compared to pre-pandemic baselines. Temporal trends indicate that incidents were most frequent during evening rush hours, suggesting operational challenges in peak periods.</p>
</section>
<section id="subway-performance" class="level2">
<h2 class="anchored" data-anchor-id="subway-performance">Subway Performance</h2>
<p>To assess subway line performance, metrics such as on-time performance, delays, and wait times were analyzed for peak and off-peak hours. The analysis identifies lines with the best performance (e.g., lines with minimal delays and high punctuality) and those with frequent disruptions. From 2020 to 2024, performance trends reveal a decline in delays during the COVID period (2020-2021) as ridership dropped. However, delays increased post-COVID (2022-2024) as ridership returned, particularly on lines serving dense boroughs like Brooklyn and Queens. Terminal on-time performance showed consistent improvement during COVID but deteriorated post-recovery. Comparisons between 2020-2021 and 2022-2024 indicate recovery efforts have been uneven, with some lines struggling to return to pre-pandemic punctuality levels.</p>
</section>
<section id="ridership" class="level2">
<h2 class="anchored" data-anchor-id="ridership">Ridership</h2>
<p>The relationship between ridership and wait assessment was analyzed to determine whether higher ridership correlates with increased wait times or complaints. During COVID, reduced ridership coincided with improved wait assessment scores, as fewer passengers alleviated operational strain. Post-COVID recovery data (2022-2024) highlights a clear trend: subway lines with higher ridership experience longer wait times and more complaints, particularly during peak hours. This correlation underscores the need for capacity planning and infrastructure investment to accommodate returning riders while maintaining service reliability.</p>
<p>Overall, these analyses provide insights into incident patterns, performance trends, and ridership dynamics, aiding in targeted improvements to subway operations and safety measures during NYC’s post-COVID recovery.</p>
</section>
<section id="key-findings-and-insights" class="level2">
<h2 class="anchored" data-anchor-id="key-findings-and-insights">Key Findings and Insights</h2>
<section id="comparative-analysis-covid-vs.-post-covid-incident-distribution" class="level3">
<h3 class="anchored" data-anchor-id="comparative-analysis-covid-vs.-post-covid-incident-distribution">Comparative Analysis: COVID vs.&nbsp;Post-COVID Incident Distribution</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Incident Reasons During COVID Period.jpg" class="img-fluid figure-img"></p>
<figcaption>MTA Incident During COVID</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Incident Reasons Post COVID Period.jpg" class="img-fluid figure-img"></p>
<figcaption>MTA Incident Post COVID</figcaption>
</figure>
</div>
<p>To ensure a balanced analysis, both the COVID (2020-2021) and post-COVID (2022-2023) periods are scaled to two years each. Pie charts will illustrate the distribution of incident categories for each period. During the COVID period, signal-related incidents were most prevalent, comprising 33.2% of all incidents, followed by persons on trackbed/police/medical incidents at 30.2%. Other notable categories included track-related incidents (10.8%), subway car incidents (8.9%), and a smaller share for stations and structure (5.7%). These distributions highlight the operational challenges of maintaining reliability and addressing immediate safety concerns during the pandemic.</p>
<p>Post-COVID, the distribution shifts significantly. Persons on trackbed/police/medical incidents rose to 33.6%, becoming the largest category, while signal-related incidents decreased to 24.6%. Track-related incidents surged to 18.2%, reflecting emerging infrastructure maintenance challenges. Categories such as subway car (8.0%), stations and structure (8.8%), and other (6.8%) incidents showed relatively smaller changes. These shifts indicate evolving priorities for MTA as the system transitions to a recovery phase, emphasizing the need for focused interventions to address rising safety and infrastructure issues.</p>
<p>Please got to this <a href="https://yantingzhao11.github.io/STA9750-2024-FALL/individualreport.html">link</a> for more detailed analysis about MTA Incidents.</p>
</section>
<section id="analysis-of-mta-subway-line-performance-peak-vs.-off-peak-delays" class="level3">
<h3 class="anchored" data-anchor-id="analysis-of-mta-subway-line-performance-peak-vs.-off-peak-delays">Analysis of MTA Subway Line Performance: Peak vs.&nbsp;Off-Peak Delays</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="animated_bar_chart.gif" class="img-fluid figure-img"></p>
<figcaption>MTA Train Delays Animation</figcaption>
</figure>
</div>
<p>The analysis of subway delay trends, comparing the COVID (2020-2021) and Post-COVID periods, highlights significant changes in the performance of various subway lines. The animated bar chart offers a visual comparison of total delays for each subway line across these two timeframes. As the animation shows, delays generally increased for most subway lines, especially as New York City began to reopen. Certain lines, such as the N, F, 6, and A, experienced substantial increases in delays, with some nearly doubling. For example, delays on the N train surged from 60,073 to 100,434 after the pandemic, marking a 67.19% increase. Similarly, the 6 train delays rose from 41,200 to 98,141. This suggests that while delays were reduced during the shutdown, the return to full service and higher ridership in the post-pandemic period has led to an uptick in disruptions.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="total_delays_animation.gif" class="img-fluid figure-img"></p>
<figcaption>MTA Train Delays Line Graph</figcaption>
</figure>
</div>
<p>Furthermore, an animated line plot was created to show how total delays changed month by month for both peak and off-peak periods. The plot revealed several trends, including a significant drop in delays during the early months of 2020, followed by a surge in delays as the city reopened and ridership increased. First quarter of 2020 saw a significant drop in delays due to the NYC shutdown in response to the COVID-19 pandemic. Mid-2021 marked the highest surge in delays, coinciding with the city’s phased reopening and increased ridership.</p>
<p>Please got to this <a href="https://chloe384.github.io/STA9750-2024-FALL/individual.html">link</a> for more detailed analysis about MTA Delays.</p>
</section>
</section>
<section id="relation-to-prior-work" class="level2">
<h2 class="anchored" data-anchor-id="relation-to-prior-work">Relation to Prior Work</h2>
<p>The MTA’s annual performance metrics reports play a crucial role in evaluating the effectiveness of its public transportation services. By using benchmarking techniques, the MTA compares its performance against peer agencies, which helps identify best practices that can be implemented to improve operational efficiency and cost-effectiveness. These performance metrics are made publicly available to ensure transparency and are submitted to oversight agencies such as the Federal Transit Administration (FTA), while also being included in the National Transit Database. This openness supports accountability and enables stakeholders to assess the MTA’s service delivery.</p>
<p>Our group’s work builds directly on this foundation by analyzing incident categories and trends, which aligns with the MTA’s commitment to using data for continuous service improvement. Our focus on incident trends, particularly post-COVID, offers more detailed insights that complement the broader performance metrics reported in the MTA’s annual reports. By focusing on the shifts in incidents during and after the pandemic, we shed light on the evolving operational challenges the MTA faces, such as issues related to maintenance, safety, and service capacity. Our analysis not only contributes to understanding the impact of these trends but also provides valuable context to help guide future decision-making within the organization.</p>
</section>
<section id="potential-next-steps-impact-of-economic-shifts-and-policy-changes" class="level2">
<h2 class="anchored" data-anchor-id="potential-next-steps-impact-of-economic-shifts-and-policy-changes">Potential Next Steps: Impact of Economic Shifts and Policy Changes</h2>
<p>To better understand subway performance, it’s important to explore how socio-economic factors like economic shifts and policy changes affect the system. Economic fluctuations, such as recessions or periods of growth, can influence ridership patterns, fare revenue, and overall demand for transit. For example, during economic downturns, people may rely more on public transportation due to job losses, whereas growth periods might see increased commuter traffic and higher demand.</p>
<p>Policies at local, state, and national levels—such as funding, subsidies, and zoning regulations—also play a critical role in shaping subway service and infrastructure. Increased funding can lead to improved services, new lines, and better maintenance, while budget cuts or shifts in favor of other transportation options could negatively impact the system. Examining the role of these policies will offer insights into the long-term viability of subway operations and guide future investment decisions.</p>
</section>
<section id="pre-pandemic-trends-and-long-term-patterns" class="level2">
<h2 class="anchored" data-anchor-id="pre-pandemic-trends-and-long-term-patterns">Pre-Pandemic Trends and Long-Term Patterns</h2>
<p>It’s crucial to analyze subway performance before the pandemic to establish a baseline for comparisons. Historical data can highlight long-term performance trends, identifying recurring issues with specific lines or infrastructure challenges that pre-date COVID-19. This analysis helps distinguish between problems caused by the pandemic and those that have been ongoing. By recognizing these patterns, more accurate projections for post-pandemic recovery can be made, enabling transit authorities to address long-standing issues while managing new challenges.</p>
</section>
<section id="variations-across-subway-lines-and-boroughs" class="level2">
<h2 class="anchored" data-anchor-id="variations-across-subway-lines-and-boroughs">Variations Across Subway Lines and Boroughs</h2>
<p>Further research should explore performance differences across subway lines and boroughs. Factors like infrastructure quality, line age, and service frequency affect service consistency. Older subway lines or those with outdated infrastructure tend to experience more maintenance issues and delays. Identifying these disparities allows for targeted solutions, such as infrastructure upgrades, more frequent service on high-demand routes, or new trains for aging lines. Additionally, evaluating the effects of recent fare increases on ridership, revenue, and service quality will provide valuable insights into the subway system’s financial health and its ability to maintain high-quality services.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/<YantingZhao11>\.github\.io\/STA9750-2024-FALL\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>